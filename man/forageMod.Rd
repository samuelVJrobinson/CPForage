% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forageMod.R
\name{forageMod}
\alias{forageMod}
\title{Run CPF model}
\usage{
forageMod(
  world,
  nests,
  iterlim = 5000,
  verbose = FALSE,
  parallel = FALSE,
  ncore = 4,
  parMethod = "SOCK",
  tol = .Machine$double.eps^0.25
)
}
\arguments{
\item{world}{World structure. List.}

\item{nests}{Nests structure. List of lists.}

\item{iterlim}{Limit to number of iterations. Default = 5000.}

\item{verbose}{Should function display progress?}

\item{parallel}{Should parallel processing be used for large tasks?}

\item{ncore}{Number of SNOW cores to use (if parallel = TRUE).}

\item{parMethod}{Message passing for parallel processing (see details below).}

\item{tol}{Tolerance range for optimization function. Default =
.Machine$double.eps^0.25.}
}
\value{
List containing world structure (competition term) and nest structure
 (forager distribution)
}
\description{
\code{forageMod} runs central-place foraging model given forager and world
data.

Function to run central-place foraging (CPF) model based on the ideal-free
distribution (IFD). Takes a list of nest parameters, and a list of world
parameters, runs the model until convergence, and then returns a list
containing a matrix of competitive effects, and a list of matrices of foraging
parameters (e.g. time in patch, foraging currency experienced at each cell).
Use \code{nests2df()} to convert this to a more readable dataframe. Currently
this only works for individual aggregations of CP foragers.
}
\details{
\code{parMethod} must be either \code{'SOCK'} (Default) or \code{'MPI'}. Requires \code{doSNOW} (Windows) and \code{RMPI} (Linux) packages.

\code{world} should be a named list containing:
\itemize{
\item \code{mu}: nectar production values (per s); matrix
\item \code{e}: energy value of nectar (J/\eqn{\mu}L); matrix
\item \code{l}: maximum nectar standing crop (\eqn{\mu}L); matrix
\item \code{f}: travel time between flowers (s); matrix
\item \code{alphaVal}: Increase in metabolic rate with load; numeric.
\item \code{flDens}: flower count per cell; matrix
\item \code{cellSize}: size of a cell (m)
\item \code{forageType}: foraging type. See \code{\link{curr}}.
}

\code{nests} should be a named list containing:
\itemize{
\item \code{xloc}: x-location of nest (column number) in world; integer.
\item \code{yloc}: y-location of nest (row number) in world; integer.
\item \code{n}: number of foragers; integer.
\item \code{whatCurr}: '\code{eff}' (efficiency) or '\code{rat}' (rate).
\item \code{sol}: solitary foraging; logical.
\item \code{constants}: named list of foraging parameters:
\itemize{
\item \code{L_max}: maximum load (\eqn{\mu}L); numeric.
\item \code{v}: maximum flight speed (m/s); numeric.
\item \code{betaVal}: reduction of flight speed with load (m/s*\eqn{\mu}L); numeric.
\item \code{p_i}: rate of nectar uptake ("licking speed", \eqn{\mu}L/s); numeric.
\item \code{h}: handling time before draining a flower (s); numeric.
\item \code{c_f}: energetic cost of flight (J/s); numeric.
\item \code{c_i}: energetic cost of non-flight (J/s); numeric.
\item \code{H}: time spent in hive/aggregation (s); numeric.
}
\item \code{steps}: step sizes to use during optimization; numeric vector.
\item \code{eps}: accuracy to use for optimization; numeric.
}
}
\examples{

#Create test world for run
nu_i<-0.3/3600 #Nectar production/hr for a single flower
flDens<-520 #Flower density/m2
e_i<-14.35 #Energetic value/unit
l_i<-1 #Canola standing crop (1uL)
f_i<-0.86 #Inter-flower flight time

#World structure
cellSize<-10 #10m cells (100m^2)
worldSize<-120 #120x120m field (100x100m field with 10m buffer zone worth nothing)
world1<-list(mu=matrix(0,worldSize/cellSize,worldSize/cellSize),
            flDens=matrix(0,worldSize/cellSize,worldSize/cellSize),
            e=matrix(0,worldSize/cellSize,worldSize/cellSize),
            l=matrix(0,worldSize/cellSize,worldSize/cellSize),
            f=matrix(0,worldSize/cellSize,worldSize/cellSize),
            alphaVal=matrix(0,worldSize/cellSize,worldSize/cellSize),
            cellSize=cellSize) #Empty world

world1$mu[c(2:11),c(2:11)]<-nu_i #Per-flower nectar production in canola-filled cells
world1$flDens[c(2:11),c(2:11)]<-flDens*cellSize^2 #Flower number per cell
world1$e[c(2:11),c(2:11)]<-e_i #Energy production in canola-filled cells
world1$l[c(2:11),c(2:11)]<-l_i #Standing crop in cells with no competition
world1$f[c(2:11),c(2:11)]<-f_i #Inter-flower flight time world1$patchLev=F
world1$alphaVal[c(2:11),c(2:11)] <- 0.013 #proportion increase in flight cost with load

world1$forageType <- 'omniscient' #Foraging style for flowers within patch

#Constants for foragers
honeybeeConstants<-list(L_max=59.5, #Max load capacity (uL) - Schmid-Hempel (1987)
                       v=7.8, #Velocity (m/s) - Unloaded flight speed (Wenner 1963)
                       betaVal=0.102/59.5, #Reduction of flight speed with load (v-v_load)/(v*L_max)
                       p_i=1, # Max loading rate (uL/s)
                       h=1.5, #Handling time per flower (s)
                       #Unloaded flight energetic cost (J/s) (Dukas and Edelstein Keshet 1998)
                       c_f=0.05,
                       c_i=0.0042, #Cost of non-flying activity
                       H=100 #Time spent in the hive (s)
                       )

#Nest structure (social rate maximizers)
nests1<-list(xloc=1,yloc=1,n=1000,whatCurr='rat',sol=FALSE,constants=honeybeeConstants,eps=0)

#Run model
testOutput1<-forageMod(world1,nests1,2000,verbose=FALSE,parallel=FALSE)

#Visualize distribution of foragers
image(testOutput1$nests$n)
}
